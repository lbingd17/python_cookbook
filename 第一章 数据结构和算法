1. Data Structures and Algorithms. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1
1.1. Unpacking a Sequence into Separate Variables 1
1.2. Unpacking Elements from Iterables of Arbitrary Length 3
1.3. Keeping the Last N Items 5
1.4. Finding the Largest or Smallest N Items 7
1.5. Implementing a Priority Queue 8
1.6. Mapping Keys to Multiple Values in a Dictionary 11
1.7. Keeping Dictionaries in Order 12
1.8. Calculating with Dictionaries 13
1.9. Finding Commonalities in Two Dictionaries 15
1.10. Removing Duplicates from a Sequence while Maintaining Order 17
1.11. Naming a Slice 18
1.12. Determining the Most Frequently Occurring Items in a Sequence 20
1.13. Sorting a List of Dictionaries by a Common Key 21
1.14. Sorting Objects Without Native Comparison Support 23
1.15. Grouping Records Together Based on a Field 24
1.16. Filtering Sequence Elements 26
1.17. Extracting a Subset of a Dictionary 28
1.18. Mapping Names to Sequence Elements 29
1.19. Transforming and Reducing Data at the Same Time 32
1.20. Combining Multiple Mappings into a Single Mapping 33

1. 数据结构和算法
1.1 将序列分解为单独的变量
p = [4, 5]
x,y = p
要求变量的总数和结构与序列相符合
data = [ 'ACME', 50, 91.1, (2012, 12, 21) ]
name, shares, price, (year, mon, day) = data

不只是tuple和list， 只要对象是可迭代的，就可以执行分解操作，包括字符串、文件、迭代器、生成器
>>> s = 'Hello'
>>> a, b, c, d, e = s

占位变量
>>> data = [ 'ACME', 50, 91.1, (2012, 12, 21) ]
>>> _, shares, price, _ = data


1.2 从任意长度的可迭代对象中分解元素
def drop_first_last(grades):
  first, *middle, last = grades
  return avg(middle)
  
>>> record = ('Dave', 'dave@example.com', '773-555-1212', '847-555-1212')
>>> name, email, *phone_numbers = user_record
>>> name
'Dave'
>>> email
'dave@example.com'
>>> phone_numbers
['773-555-1212', '847-555-1212']
 
*式的语法在迭代变长的tuple组成tuple组成的list时尤为有用
records = [
  ('foo', 1, 2),
  ('bar', 'hello'),
  ('foo', 3, 4),
]
def do_foo(x, y):
  print('foo', x, y)
def do_bar(s):
  print('bar', s)
for tag, *args in records:
  if tag == 'foo':
    do_foo(*args)
  elif tag == 'bar':
    do_bar(*args)
  
  
  1.3 保存最后N的元素

from collections import deque
deque(maxlen=N)创建一个固定长度的队列
append appendleft pop popleft

from collections import deque
def search(lines, pattern, history=5):
  previous_lines = deque(maxlen=history)
  for line in lines:
    if pattern in line:
      yield line, previous_lines
    previous_lines.append(line)
# Example use on a file
if __name__ == '__main__':
  with open('somefile.txt') as f:
    for line, prevlines in search(f, 'python', 5):
      for pline in prevlines:
        print(pline, end='')
      print(line, end='')
      print('-'*20)
  ??不太理解yield
  
 1.4 找到最大或者最小的N个元素
 import heapq
 nums=[1,2,33,4,8,5]
 headq.nlargest(3, nums)
 headq.smallest(3, nums)


cheap = heapq.nsmallest(3, portfolio, key=lambda s: s['price'])
expensive = heapq.nlargest(3, portfolio, key=lambda s: s['price'])


>>> nums = [1, 8, 2, 23, 7, -4, 18, 23, 42, 37, 2]
>>> import heapq
>>> heap = list(nums)
>>> heapq.heapify(heap)
>>> heap
[-4, 2, 1, 23, 7, 2, 18, 23, 42, 37, 8]
>>>
The most important feature of a heap is that heap[0] is always the smallest item. Moreover,
subsequent items can be easily found using the heapq.heappop() method, which
pops off the first item and replaces it with the next smallest item (an operation that
requires O(log N) operations where N is the size of the heap). For example, to find the
three smallest items, you would do this:
>>> heapq.heappop(heap)
-4
>>> heapq.heappop(heap)
1
>>> heapq.heappop(heap)
  
  The nlargest() and nsmallest() functions are most appropriate if you are trying to
find a relatively small number of items.

If you are simply trying to find the single smallest or largest item (N=1), it is faster to use min() and max().

Similarly, if N is about the same size as the collection itself, it is usually faster to sort it first and take a slice (i.e.,
use sorted(items)[:N] or sorted(items)[-N:]). 

It should be noted that the actual implementation of nlargest() and nsmallest() is adaptive in how it operates and will
implementation of nlargest() and nsmallest() is adaptive in how it operates and will
carry out some of these optimizations on your behalf (e.g., using sorting if N is close to
the same size as the input).

可参考：heapq模块的底层实现细节？
